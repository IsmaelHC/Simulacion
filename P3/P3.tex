\documentclass{article}
\usepackage[utf8]{inputenc}
\setlength{\parskip}{5pt} % esp. entre parrafos
\setlength{\parindent}{0pt} % esp. al inicio de un parrafo
\usepackage[spanish]{babel}
\usepackage[sort&compress,numbers]{natbib} % referencias
\usepackage[top=25mm,left=20mm,right=20mm,bottom=25mm]{geometry} % margenes
\usepackage{graphicx} % poner figuras
\usepackage{color,listings}
\usepackage{tikz}
\usepackage{minted}
\usepackage{caption}
\usepackage{subcaption}
\usetikzlibrary{automata,topaths}
\renewcommand\lstlistingname{Código}
\title{P3}
\author{Ismael Crespo}
\date{\today}

\begin{document}

\maketitle

\section{Introducción.}
Conocer el orden como se realizan los códigos computacionales es de suma importancia para realizar códigos eficientes, este trabajo presenta diferentes rutas para llegar a un mismo objetivo, encontrar los números primos $p$ en una secuencia numérica, y se comparan los tiempos de ejecución para concluir cuál es la mejor opción, la comparación entre los distintos métodos se realizó en  \emph{R 4.1.2}.
\section{Objetivos.}
1.-Examinar las diferencias en los tiempos de ejecución variando, el orden de los números, la cantidad de núcleos asignados al cluster y la variante de la rutina para determinar si el número es primo.
2.-Encontrar todos los divisores de un número (todos los enteros mayores a uno y menores al número mismo que lo dividen exactamente) y examinar si las conclusiones cambian.
3.-Encontrar los factores y sus multiplicidades, es decir, que encuentre para  aquellos números primos $1<p\leq n  $ y sus potencias para que el producto de los factores con esas potencias de $n$ y examinar nuevamente si este cambio afectó las conclusiones.
\section{Programación en R.}
Tomando tres rutinas desarrolladas por E.Schaeffer \citep{E.Schaeffer} para encontrar números primos, pasando de rutinas robustas a rutinas mas simplificadas que retiren obviedades de los ciclos, p. ej., si un número no es divisible por $2$, tampoco lo será para los demás números pares. (Código \ref{R1}).
El equipo utilizado para la medición de rendimientos es una computadora portátil \emph{Acer E5-573 } con un Procesador \emph{Intel Core i5 2.20 GHz},una memoria RAM instalada de 8.0 GB y un sistema operativo de 64 bits con 4 núcleos.Para consulta más amplia consulte la referencia \citep{REPOP2}
\lstset{basicstyle=\ttfamily, keywordstyle=\bfseries}
\begin{lstlisting}[frame=single,numbers=left,language=R,caption=Función eliminando los elementos que no son divisibles entre $2$ para encontrar los número primos. \label{R1}]
  primo_2 <- function(n) {
    if (n < 4) {
        return(TRUE)
    }
    if (n %% 2 == 0) { # par
        return(FALSE)
    }
    for (i in seq(3, max(3, n - 1), 2)) {
        if (n %% i == 0) {
            return(FALSE)
        }}
    return(TRUE)}
\end{lstlisting}  
Cada una de las tres rutinas fueron evaluadas con los mismos números, sin embargo, para analizarlos estos se ordenaron de manera ascendente (\texttt{ot}), descendente (\texttt{it}) y aleatorio (\texttt{at}), dichas combinaciones de rutinas y ordenamiento numérico fueron evaluadas tanto para 3 núcleos y 1 núcleo por lo que para la primera parte del trabajo se realizaron $18$ pruebas diferentes (Código \ref{R1.1}).
\lstset{basicstyle=\ttfamily, keywordstyle=\bfseries}
\begin{lstlisting}[frame=single,numbers=left,language=R,caption=La rutina 3 evaluada para cada ordenamiento de los números y la selección de los núcleos a utilizar. \label{R1.1}]
registerDoParallel(makeCluster(detectCores() - 1)) #Nucleos a utilizar
ot_3<- c(ot_3, system.time(foreach(n = original, .combine=c)
%dopar% primo_3(n))[3]) # de menor a mayor
it_3 <- c(it_3, system.time(foreach(n = invertido, .combine=c)
%dopar% primo_3(n))[3]) # de mayor a menor
at_3<- c(at_3, system.time(foreach(n = aleatorio, .combine=c) 
%dopar% primo_3(n))[3]) # orden aleatorio
\end{lstlisting}
La segunda parte del trabajo encuentra el total de números que dividen exactamente a $n$, posteriormente se encuentran nuevamente todos los valores ($p$) y la potencia $x$ a la que $p$ tiene que ser elevado para ser igual a $n$, La Ecuación 1 describe el enunciado y la Ecuación 2 muestra la forma algebraica para encontrar el valor de x (véase el Código \ref{R2}).La segunda parte del trabajo en su totalidad fue evaluada utilizando tres núcleos.
\begin{equation}
    p^x=n
\end{equation}
\begin{equation}
    x=log_pn
\end{equation}
 \begin{lstlisting}[frame=single,numbers=left,language=R,caption=Función para encontrar el valor de la potencia $x$. \label{R2}]
potencia<- function(n) {
    if (n == 1 || n == 2) {
        return(TRUE)
    }
    if (n %% 2 == 0) {
        return(FALSE)
    }
    for (i in seq(3, max(3, ceiling(sqrt(n))), 2)) {
        if ((n %% i) == 0) {
            return(FALSE)
        } else { #Encuentra numero primo
           return(x=log(i,base=hasta)) #Encuentra la potencia
           }}}
\end{lstlisting} 
\section{Resultados.}
La figura \ref{F1} muestra los  tiempos en segundos que tomo encontrar los números primos desde $1$ a $4000$, la Figura \ref{fig1} muestra los tiempos requeridos utilizando solamente un núcleo, de aquí, por conveniencia se decidió comparar la rutina 3 con cada ordenamiento utilizando 1 y 3 núcleos Figura \ref{fig1b}. De la \ref{fig1} se deduce que la rutina 3 es la mas eficiente, posteriormente de la \ref{fig1b} se observa un mejor rendimiento cuando se dedican 3 núcleos a esta operación. 

\begin{figure}
     \centering
     \begin{subfigure}[b]{.8\textwidth}
         \centering
         \includegraphics[width=\textwidth]{fig1.png}
         \caption{Tiempos requeridos para correr cada rutina(1,2,3),para cada orden numérico(ot,it,at).}
         \label{fig1}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{.8\textwidth}
         \centering
         \includegraphics[width=\textwidth]{fig1b.png}
         \caption{Tiempos requeridos para correr la rutina 3, con cada orden numérico, para 1 y 3 núcleos.}
         \label{fig1b}
     \end{subfigure}
     \caption{Comparación de los tiempos requeridos para cada configuración de las rutina.}
        \label{F1}
\end{figure}
\bibliography{simu}
\bibliographystyle{plainnat}
\end{document}
